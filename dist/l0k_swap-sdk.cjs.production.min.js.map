{"version":3,"file":"l0k_swap-sdk.cjs.production.min.js","sources":["../src/errors.ts","../src/constants.ts","../src/utils.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/entities/fractions/percent.ts","../src/entities/trade.ts","../src/router.ts","../src/fetcher.ts"],"sourcesContent":["// see https://stackoverflow.com/a/41102306\r\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\r\n\r\n/**\r\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\r\n * obtained by sending any amount of input.\r\n */\r\nexport class InsufficientReservesError extends Error {\r\n  public readonly isInsufficientReservesError = true as const\r\n\r\n  public constructor() {\r\n    super()\r\n    this.name = this.constructor.name\r\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\r\n  }\r\n}\r\n\r\n/**\r\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\r\n * than the price of a single unit of output after fees.\r\n */\r\nexport class InsufficientInputAmountError extends Error {\r\n  public readonly isInsufficientInputAmountError = true as const\r\n\r\n  public constructor() {\r\n    super()\r\n    this.name = this.constructor.name\r\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\r\n  }\r\n}\r\n","import JSBI from 'jsbi'\r\nimport { encodeShortString } from 'starknet/utils/shortString'\r\nimport { StarknetChainId } from 'starknet/constants'\r\n\r\n// exports for external consumption\r\nexport type BigintIsh = JSBI | bigint | string\r\n\r\nexport { StarknetChainId as ChainId } from 'starknet/constants'\r\n\r\nexport enum TradeType {\r\n  EXACT_INPUT,\r\n  EXACT_OUTPUT\r\n}\r\n\r\nexport enum Rounding {\r\n  ROUND_DOWN,\r\n  ROUND_HALF_UP,\r\n  ROUND_UP\r\n}\r\n\r\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\r\n\r\n// exports for internal consumption\r\nexport const ZERO = JSBI.BigInt(0)\r\nexport const ONE = JSBI.BigInt(1)\r\nexport const TWO = JSBI.BigInt(2)\r\nexport const THREE = JSBI.BigInt(3)\r\nexport const FIVE = JSBI.BigInt(5)\r\nexport const TEN = JSBI.BigInt(10)\r\nexport const _100 = JSBI.BigInt(100)\r\nexport const FEES_NUMERATOR = JSBI.BigInt(9970)\r\nexport const FEES_DENOMINATOR = JSBI.BigInt(10000)\r\n\r\nexport enum SolidityType {\r\n  uint8 = 'uint8',\r\n  uint256 = 'uint256'\r\n}\r\n\r\nexport const SOLIDITY_TYPE_MAXIMA = {\r\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\r\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\r\n}\r\n\r\nexport const PAIR_CONTRACT_CLASS_HASH = '0x231adde42526bad434ca2eb983efdd64472638702f87f97e6e3c084f264e06f'\r\n\r\nexport const FACTORY_ADDRESSES: {\r\n  [chainId in StarknetChainId]: string\r\n} = {\r\n  [StarknetChainId.MAINNET]: '',\r\n  [StarknetChainId.TESTNET]: '0x06c31f39524388c982045988de3788530605ed08b10389def2e7b1dd09d19308'\r\n}\r\n\r\nexport const CONTRACT_ADDRESS_PREFIX = encodeShortString('STARKNET_CONTRACT_ADDRESS')\r\n","import invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\nimport { toBN } from 'starknet/utils/number'\r\nimport { computeHashOnElements, pedersen } from 'starknet/dist/utils/hash'\r\nimport { validateAndParseAddress as getAddress } from 'starknet/utils/address'\r\n\r\nimport {\r\n  BigintIsh,\r\n  ZERO,\r\n  ONE,\r\n  TWO,\r\n  THREE,\r\n  SolidityType,\r\n  SOLIDITY_TYPE_MAXIMA,\r\n  FACTORY_ADDRESSES,\r\n  PAIR_CONTRACT_CLASS_HASH,\r\n  CONTRACT_ADDRESS_PREFIX\r\n} from './constants'\r\nimport { Token } from '.'\r\n\r\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\r\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\r\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\r\n}\r\n\r\n// warns if addresses are not checksummed\r\nexport function validateAndParseAddress(address: string): string {\r\n  try {\r\n    const checksummedAddress = getAddress(address)\r\n    // warning(address === checksummedAddress, `${address} is not checksummed.`)\r\n    return checksummedAddress\r\n  } catch (error) {\r\n    invariant(false, `${address} is not a valid address.`)\r\n  }\r\n}\r\n\r\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\r\n  return bigintIsh instanceof JSBI ? bigintIsh : typeof bigintIsh === 'bigint' ? JSBI.BigInt(bigintIsh.toString()) : JSBI.BigInt(bigintIsh)\r\n}\r\n\r\n// mock the on-chain sqrt function\r\nexport function sqrt(y: JSBI): JSBI {\r\n  validateSolidityTypeInstance(y, SolidityType.uint256)\r\n  let z: JSBI = ZERO\r\n  let x: JSBI\r\n  if (JSBI.greaterThan(y, THREE)) {\r\n    z = y\r\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\r\n    while (JSBI.lessThan(x, z)) {\r\n      z = x\r\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\r\n    }\r\n  } else if (JSBI.notEqual(y, ZERO)) {\r\n    z = ONE\r\n  }\r\n  return z\r\n}\r\n\r\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\r\n// `maxSize` by removing the last item\r\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\r\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\r\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\r\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\r\n\r\n  // short circuit first item add\r\n  if (items.length === 0) {\r\n    items.push(add)\r\n    return null\r\n  } else {\r\n    const isFull = items.length === maxSize\r\n    // short circuit if full and the additional item does not come before the last item\r\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\r\n      return add\r\n    }\r\n\r\n    let lo = 0,\r\n      hi = items.length\r\n\r\n    while (lo < hi) {\r\n      const mid = (lo + hi) >>> 1\r\n      if (comparator(items[mid], add) <= 0) {\r\n        lo = mid + 1\r\n      } else {\r\n        hi = mid\r\n      }\r\n    }\r\n    items.splice(lo, 0, add)\r\n    return isFull ? items.pop() ?? null : null\r\n  }\r\n}\r\n\r\nexport function getPairAddress(tokenA: Token, tokenB: Token) {\r\n  const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checksr\r\n  const salt = pedersen([tokens[0].address, tokens[1].address])\r\n  const constructorCalldataHash = computeHashOnElements([])\r\n\r\n  return computeHashOnElements([CONTRACT_ADDRESS_PREFIX, FACTORY_ADDRESSES[tokenA.chainId], salt, PAIR_CONTRACT_CLASS_HASH, constructorCalldataHash])\r\n}\r\n\r\nexport function isEqualAddress(addressA: string, addressB: string): boolean {\r\n  return toBN(addressA).eq(toBN(addressB))\r\n}\r\n\r\nexport function sortsBefore(addressA: string, addressB: string): boolean {\r\n  return toBN(addressA).lt(toBN(addressB))\r\n}\r\n","import invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\nimport { ChainId, SolidityType } from '../constants'\r\nimport { isEqualAddress, sortsBefore, validateAndParseAddress, validateSolidityTypeInstance } from '../utils'\r\n\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport class Token {\r\n  public readonly decimals: number\r\n  public readonly symbol?: string\r\n  public readonly name?: string\r\n  public readonly chainId: ChainId\r\n  public readonly address: string\r\n\r\n  public constructor(chainId: ChainId, address: string, decimals: number, symbol?: string, name?: string) {\r\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8)\r\n\r\n    this.decimals = decimals\r\n    this.symbol = symbol\r\n    this.name = name\r\n    this.chainId = chainId\r\n    this.address = validateAndParseAddress(address)\r\n  }\r\n\r\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\r\n  public equals(other: Token): boolean {\r\n    // short circuit on reference equality\r\n    if (this === other) {\r\n      return true\r\n    }\r\n    return this.chainId === other.chainId && isEqualAddress(this.address, other.address)\r\n  }\r\n\r\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\r\n  public sortsBefore(other: Token): boolean {\r\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\r\n    invariant(this.address !== other.address, 'ADDRESSES')\r\n\r\n    return sortsBefore(this.address, other.address)\r\n  }\r\n}\r\n\r\n/**\r\n * Compares two currencies for equality\r\n */\r\nexport function currencyEquals(currencyA: Token, currencyB: Token): boolean {\r\n  if (currencyA instanceof Token && currencyB instanceof Token) {\r\n    return currencyA.equals(currencyB)\r\n  } else if (currencyA instanceof Token) {\r\n    return false\r\n  } else if (currencyB instanceof Token) {\r\n    return false\r\n  } else {\r\n    return currencyA === currencyB\r\n  }\r\n}\r\n","import invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\nimport _Decimal from 'decimal.js-light'\r\nimport _Big from 'big.js'\r\nimport toFormat from 'toformat'\r\n\r\nimport { BigintIsh, Rounding } from '../../constants'\r\nimport { ONE } from '../../constants'\r\nimport { parseBigintIsh } from '../../utils'\r\n\r\nconst Decimal = toFormat(_Decimal)\r\nconst Big = toFormat(_Big)\r\n\r\nconst toSignificantRounding = {\r\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\r\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\r\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\r\n}\r\n\r\nconst toFixedRounding = {\r\n  [Rounding.ROUND_DOWN]: 0,\r\n  [Rounding.ROUND_HALF_UP]: 1,\r\n  [Rounding.ROUND_UP]: 3\r\n}\r\n\r\nexport class Fraction {\r\n  public readonly numerator: JSBI\r\n  public readonly denominator: JSBI\r\n\r\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\r\n    this.numerator = parseBigintIsh(numerator)\r\n    this.denominator = parseBigintIsh(denominator)\r\n  }\r\n\r\n  // performs floor division\r\n  public get quotient(): JSBI {\r\n    return JSBI.divide(this.numerator, this.denominator)\r\n  }\r\n\r\n  // remainder after floor division\r\n  public get remainder(): Fraction {\r\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\r\n  }\r\n\r\n  public invert(): Fraction {\r\n    return new Fraction(this.denominator, this.numerator)\r\n  }\r\n\r\n  public add(other: Fraction | BigintIsh): Fraction {\r\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\r\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\r\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\r\n    }\r\n    return new Fraction(\r\n      JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)),\r\n      JSBI.multiply(this.denominator, otherParsed.denominator)\r\n    )\r\n  }\r\n\r\n  public subtract(other: Fraction | BigintIsh): Fraction {\r\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\r\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\r\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\r\n    }\r\n    return new Fraction(\r\n      JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)),\r\n      JSBI.multiply(this.denominator, otherParsed.denominator)\r\n    )\r\n  }\r\n\r\n  public lessThan(other: Fraction | BigintIsh): boolean {\r\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\r\n    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator))\r\n  }\r\n\r\n  public equalTo(other: Fraction | BigintIsh): boolean {\r\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\r\n    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator))\r\n  }\r\n\r\n  public greaterThan(other: Fraction | BigintIsh): boolean {\r\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\r\n    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator))\r\n  }\r\n\r\n  public multiply(other: Fraction | BigintIsh): Fraction {\r\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\r\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator))\r\n  }\r\n\r\n  public divide(other: Fraction | BigintIsh): Fraction {\r\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\r\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator))\r\n  }\r\n\r\n  public toSignificant(significantDigits: number, format: object = { groupSeparator: '' }, rounding: Rounding = Rounding.ROUND_HALF_UP): string {\r\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\r\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\r\n\r\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\r\n    const quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits)\r\n    return quotient.toFormat(quotient.decimalPlaces(), format)\r\n  }\r\n\r\n  public toFixed(decimalPlaces: number, format: object = { groupSeparator: '' }, rounding: Rounding = Rounding.ROUND_HALF_UP): string {\r\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\r\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\r\n\r\n    Big.DP = decimalPlaces\r\n    Big.RM = toFixedRounding[rounding]\r\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\r\n  }\r\n}\r\n","import { Token } from '../token'\r\nimport invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\nimport toFormat from 'toformat'\r\n\r\nimport { BigintIsh, Rounding, SolidityType, TEN } from '../../constants'\r\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\r\nimport { Fraction } from './fraction'\r\nimport _Big from 'big.js'\r\n\r\nconst Big = toFormat(_Big)\r\nexport class TokenAmount extends Fraction {\r\n  public readonly token: Token\r\n\r\n  // amount _must_ be raw, i.e. in the native representation\r\n  public constructor(token: Token, amount: BigintIsh) {\r\n    const parsedAmount = parseBigintIsh(amount)\r\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\r\n\r\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(token.decimals)))\r\n    this.token = token\r\n  }\r\n\r\n  public get raw(): JSBI {\r\n    return this.numerator\r\n  }\r\n\r\n  public add(other: TokenAmount): TokenAmount {\r\n    invariant(this.token.equals(other.token), 'TOKEN')\r\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw))\r\n  }\r\n\r\n  public subtract(other: TokenAmount): TokenAmount {\r\n    invariant(this.token.equals(other.token), 'TOKEN')\r\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw))\r\n  }\r\n\r\n  public toSignificant(significantDigits = 12, format?: object, rounding: Rounding = Rounding.ROUND_DOWN): string {\r\n    return super.toSignificant(significantDigits, format, rounding)\r\n  }\r\n\r\n  public toFixed(decimalPlaces: number = this.token.decimals, format?: object, rounding: Rounding = Rounding.ROUND_DOWN): string {\r\n    invariant(decimalPlaces <= this.token.decimals, 'DECIMALS')\r\n    return super.toFixed(decimalPlaces, format, rounding)\r\n  }\r\n\r\n  public toExact(format: object = { groupSeparator: '' }): string {\r\n    Big.DP = this.token.decimals\r\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\r\n  }\r\n}\r\n","import { Token } from '../token'\r\nimport { TokenAmount } from './tokenAmount'\r\nimport { currencyEquals } from '../token'\r\nimport invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\n\r\nimport { BigintIsh, Rounding, TEN } from '../../constants'\r\nimport { Route } from '../route'\r\nimport { Fraction } from './fraction'\r\n\r\nexport class Price extends Fraction {\r\n  public readonly baseCurrency: Token // input i.e. denominator\r\n  public readonly quoteCurrency: Token // output i.e. numerator\r\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\r\n\r\n  public static fromRoute(route: Route): Price {\r\n    const prices: Price[] = []\r\n    for (const [i, pair] of route.pairs.entries()) {\r\n      prices.push(\r\n        route.path[i].equals(pair.token0)\r\n          ? new Price(pair.reserve0.token, pair.reserve1.token, pair.reserve0.raw, pair.reserve1.raw)\r\n          : new Price(pair.reserve1.token, pair.reserve0.token, pair.reserve1.raw, pair.reserve0.raw)\r\n      )\r\n    }\r\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\r\n  }\r\n\r\n  // denominator and numerator _must_ be raw, i.e. in the native representation\r\n  public constructor(baseCurrency: Token, quoteCurrency: Token, denominator: BigintIsh, numerator: BigintIsh) {\r\n    super(numerator, denominator)\r\n\r\n    this.baseCurrency = baseCurrency\r\n    this.quoteCurrency = quoteCurrency\r\n    this.scalar = new Fraction(\r\n      JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)),\r\n      JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals))\r\n    )\r\n  }\r\n\r\n  public get raw(): Fraction {\r\n    return new Fraction(this.numerator, this.denominator)\r\n  }\r\n\r\n  public get adjusted(): Fraction {\r\n    return super.multiply(this.scalar)\r\n  }\r\n\r\n  public invert(): Price {\r\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\r\n  }\r\n\r\n  public multiply(other: Price): Price {\r\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\r\n    const fraction = super.multiply(other)\r\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\r\n  }\r\n\r\n  // performs floor division on overflow\r\n  public quote(currencyAmount: TokenAmount): TokenAmount {\r\n    invariant(currencyEquals(currencyAmount.token, this.baseCurrency), 'TOKEN')\r\n\r\n    return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\r\n  }\r\n\r\n  public toSignificant(significantDigits = 6, format?: object, rounding?: Rounding): string {\r\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\r\n  }\r\n\r\n  public toFixed(decimalPlaces = 4, format?: object, rounding?: Rounding): string {\r\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\r\n  }\r\n}\r\n","import { Price } from './fractions/price'\r\nimport { TokenAmount } from './fractions/tokenAmount'\r\nimport invariant from 'tiny-invariant'\r\nimport JSBI from 'jsbi'\r\nimport { BigintIsh, MINIMUM_LIQUIDITY, ZERO, ONE, FIVE, FEES_NUMERATOR, FEES_DENOMINATOR, ChainId } from '../constants'\r\nimport { sqrt, parseBigintIsh, getPairAddress } from '../utils'\r\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\r\nimport { Token } from './token'\r\n\r\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\r\n\r\nexport class Pair {\r\n  public readonly liquidityToken: Token\r\n  readonly tokenAmounts: [TokenAmount, TokenAmount]\r\n\r\n  public static getAddress(tokenA: Token, tokenB: Token): string {\r\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\r\n\r\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\r\n      PAIR_ADDRESS_CACHE = {\r\n        ...PAIR_ADDRESS_CACHE,\r\n        [tokens[0].address]: {\r\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\r\n          [tokens[1].address]: getPairAddress(tokenA, tokenB)\r\n        }\r\n      }\r\n    }\r\n\r\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\r\n  }\r\n\r\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\r\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\r\n      ? [tokenAmountA, tokenAmountB]\r\n      : [tokenAmountB, tokenAmountA]\r\n    this.liquidityToken = new Token(\r\n      tokenAmounts[0].token.chainId,\r\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\r\n      18,\r\n      '10k Swap LP',\r\n      '10k Swap'\r\n    )\r\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\r\n  }\r\n\r\n  /**\r\n   * Returns true if the token is either token0 or token1\r\n   * @param token to check\r\n   */\r\n  public involvesToken(token: Token): boolean {\r\n    return token.equals(this.token0) || token.equals(this.token1)\r\n  }\r\n\r\n  /**\r\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\r\n   */\r\n  public get token0Price(): Price {\r\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\r\n  }\r\n\r\n  /**\r\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\r\n   */\r\n  public get token1Price(): Price {\r\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\r\n  }\r\n\r\n  /**\r\n   * Return the price of the given token in terms of the other token in the pair.\r\n   * @param token token to return price of\r\n   */\r\n  public priceOf(token: Token): Price {\r\n    invariant(this.involvesToken(token), 'TOKEN')\r\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\r\n  }\r\n\r\n  /**\r\n   * Returns the chain ID of the tokens in the pair.\r\n   */\r\n  public get chainId(): ChainId {\r\n    return this.token0.chainId\r\n  }\r\n\r\n  public get token0(): Token {\r\n    return this.tokenAmounts[0].token\r\n  }\r\n\r\n  public get token1(): Token {\r\n    return this.tokenAmounts[1].token\r\n  }\r\n\r\n  public get reserve0(): TokenAmount {\r\n    return this.tokenAmounts[0]\r\n  }\r\n\r\n  public get reserve1(): TokenAmount {\r\n    return this.tokenAmounts[1]\r\n  }\r\n\r\n  public reserveOf(token: Token): TokenAmount {\r\n    invariant(this.involvesToken(token), 'TOKEN')\r\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\r\n  }\r\n\r\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\r\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN')\r\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\r\n      throw new InsufficientReservesError()\r\n    }\r\n    const inputReserve = this.reserveOf(inputAmount.token)\r\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\r\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\r\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\r\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\r\n    const outputAmount = new TokenAmount(inputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator))\r\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\r\n      throw new InsufficientInputAmountError()\r\n    }\r\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\r\n  }\r\n\r\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\r\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN')\r\n    if (\r\n      JSBI.equal(this.reserve0.raw, ZERO) ||\r\n      JSBI.equal(this.reserve1.raw, ZERO) ||\r\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\r\n    ) {\r\n      throw new InsufficientReservesError()\r\n    }\r\n\r\n    const outputReserve = this.reserveOf(outputAmount.token)\r\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\r\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\r\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\r\n    const inputAmount = new TokenAmount(\r\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\r\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\r\n    )\r\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\r\n  }\r\n\r\n  public getLiquidityMinted(totalSupply: TokenAmount, tokenAmountA: TokenAmount, tokenAmountB: TokenAmount): TokenAmount {\r\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\r\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\r\n      ? [tokenAmountA, tokenAmountB]\r\n      : [tokenAmountB, tokenAmountA]\r\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\r\n\r\n    let liquidity: JSBI\r\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\r\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\r\n    } else {\r\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\r\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\r\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\r\n    }\r\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\r\n      throw new InsufficientInputAmountError()\r\n    }\r\n    return new TokenAmount(this.liquidityToken, liquidity)\r\n  }\r\n\r\n  public getLiquidityValue(token: Token, totalSupply: TokenAmount, liquidity: TokenAmount, feeOn = false, kLast?: BigintIsh): TokenAmount {\r\n    invariant(this.involvesToken(token), 'TOKEN')\r\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\r\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\r\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\r\n\r\n    let totalSupplyAdjusted: TokenAmount\r\n    if (!feeOn) {\r\n      totalSupplyAdjusted = totalSupply\r\n    } else {\r\n      invariant(!!kLast, 'K_LAST')\r\n      const kLastParsed = parseBigintIsh(kLast)\r\n      if (!JSBI.equal(kLastParsed, ZERO)) {\r\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\r\n        const rootKLast = sqrt(kLastParsed)\r\n        if (JSBI.greaterThan(rootK, rootKLast)) {\r\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\r\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\r\n          const feeLiquidity = JSBI.divide(numerator, denominator)\r\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\r\n        } else {\r\n          totalSupplyAdjusted = totalSupply\r\n        }\r\n      } else {\r\n        totalSupplyAdjusted = totalSupply\r\n      }\r\n    }\r\n\r\n    return new TokenAmount(token, JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw))\r\n  }\r\n}\r\n","import { ChainId } from '../constants'\r\nimport invariant from 'tiny-invariant'\r\n\r\nimport { Token } from './token'\r\nimport { Pair } from './pair'\r\nimport { Price } from './fractions/price'\r\n\r\nexport class Route {\r\n  public readonly pairs: Pair[]\r\n  public readonly path: Token[]\r\n  public readonly input: Token\r\n  public readonly output: Token\r\n  public readonly midPrice: Price\r\n\r\n  public constructor(pairs: Pair[], input: Token, output?: Token) {\r\n    invariant(pairs.length > 0, 'PAIRS')\r\n    invariant(\r\n      pairs.every(pair => pair.chainId === pairs[0].chainId),\r\n      'CHAIN_IDS'\r\n    )\r\n    invariant((input instanceof Token && pairs[0].involvesToken(input)) || 'INPUT')\r\n    invariant(typeof output === 'undefined' || (output instanceof Token && pairs[pairs.length - 1].involvesToken(output)), 'OUTPUT')\r\n\r\n    const path: Token[] = [input]\r\n    for (const [i, pair] of pairs.entries()) {\r\n      const currentInput = path[i]\r\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\r\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\r\n      path.push(output)\r\n    }\r\n\r\n    this.pairs = pairs\r\n    this.path = path\r\n    this.midPrice = Price.fromRoute(this)\r\n    this.input = input\r\n    this.output = output ?? path[path.length - 1]\r\n  }\r\n\r\n  public get chainId(): ChainId {\r\n    return this.pairs[0].chainId\r\n  }\r\n}\r\n","import { Rounding, _100 } from '../../constants'\r\nimport { Fraction } from './fraction'\r\n\r\nconst _100_PERCENT = new Fraction(_100)\r\n\r\nexport class Percent extends Fraction {\r\n  public toSignificant(significantDigits = 5, format?: object, rounding?: Rounding): string {\r\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\r\n  }\r\n\r\n  public toFixed(decimalPlaces = 2, format?: object, rounding?: Rounding): string {\r\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\r\n  }\r\n}\r\n","import invariant from 'tiny-invariant'\r\n\r\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\r\nimport { sortedInsert } from '../utils'\r\nimport { Fraction } from './fractions/fraction'\r\nimport { Percent } from './fractions/percent'\r\nimport { Price } from './fractions/price'\r\nimport { TokenAmount } from './fractions/tokenAmount'\r\nimport { Pair } from './pair'\r\nimport { Route } from './route'\r\nimport { currencyEquals, Token } from './token'\r\n\r\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\r\nfunction computePriceImpact(midPrice: Price, inputAmount: TokenAmount, outputAmount: TokenAmount): Percent {\r\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\r\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\r\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\r\n  return new Percent(slippage.numerator, slippage.denominator)\r\n}\r\n\r\n// minimal interface so the input output comparator may be shared across types\r\ninterface InputOutput {\r\n  readonly inputAmount: TokenAmount\r\n  readonly outputAmount: TokenAmount\r\n}\r\n\r\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\r\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\r\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\r\n  // must have same input and output token for comparison\r\n  invariant(currencyEquals(a.inputAmount.token, b.inputAmount.token), 'INPUT_CURRENCY')\r\n  invariant(currencyEquals(a.outputAmount.token, b.outputAmount.token), 'OUTPUT_CURRENCY')\r\n  if (a.outputAmount.equalTo(b.outputAmount)) {\r\n    if (a.inputAmount.equalTo(b.inputAmount)) {\r\n      return 0\r\n    }\r\n    // trade A requires less input than trade B, so A should come first\r\n    if (a.inputAmount.lessThan(b.inputAmount)) {\r\n      return -1\r\n    } else {\r\n      return 1\r\n    }\r\n  } else {\r\n    // tradeA has less output than trade B, so should come second\r\n    if (a.outputAmount.lessThan(b.outputAmount)) {\r\n      return 1\r\n    } else {\r\n      return -1\r\n    }\r\n  }\r\n}\r\n\r\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\nexport function tradeComparator(a: Trade, b: Trade) {\r\n  const ioComp = inputOutputComparator(a, b)\r\n  if (ioComp !== 0) {\r\n    return ioComp\r\n  }\r\n\r\n  // consider lowest slippage next, since these are less likely to fail\r\n  if (a.priceImpact.lessThan(b.priceImpact)) {\r\n    return -1\r\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\r\n    return 1\r\n  }\r\n\r\n  // finally consider the number of hops since each hop costs gas\r\n  return a.route.path.length - b.route.path.length\r\n}\r\n\r\nexport interface BestTradeOptions {\r\n  // how many results to return\r\n  maxNumResults?: number\r\n  // the maximum number of hops a trade should contain\r\n  maxHops?: number\r\n}\r\n\r\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport class Trade {\r\n  /**\r\n   * The route of the trade, i.e. which pairs the trade goes through.\r\n   */\r\n  public readonly route: Route\r\n  /**\r\n   * The type of the trade, either exact in or exact out.\r\n   */\r\n  public readonly tradeType: TradeType\r\n  /**\r\n   * The input amount for the trade assuming no slippage.\r\n   */\r\n  public readonly inputAmount: TokenAmount\r\n  /**\r\n   * The output amount for the trade assuming no slippage.\r\n   */\r\n  public readonly outputAmount: TokenAmount\r\n  /**\r\n   * The price expressed in terms of output amount/input amount.\r\n   */\r\n  public readonly executionPrice: Price\r\n  /**\r\n   * The mid price after the trade executes assuming no slippage.\r\n   */\r\n  public readonly nextMidPrice: Price\r\n  /**\r\n   * The percent difference between the mid price before the trade and the trade execution price.\r\n   */\r\n  public readonly priceImpact: Percent\r\n\r\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\r\n  public static exactIn(route: Route, amountIn: TokenAmount): Trade {\r\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\r\n  }\r\n\r\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */\r\n  public static exactOut(route: Route, amountOut: TokenAmount): Trade {\r\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\r\n  }\r\n\r\n  public constructor(route: Route, amount: TokenAmount, tradeType: TradeType) {\r\n    const amounts: TokenAmount[] = new Array(route.path.length)\r\n    const nextPairs: Pair[] = new Array(route.pairs.length)\r\n    if (tradeType === TradeType.EXACT_INPUT) {\r\n      invariant(currencyEquals(amount.token, route.input), 'INPUT')\r\n      amounts[0] = amount\r\n      for (let i = 0; i < route.path.length - 1; i++) {\r\n        const pair = route.pairs[i]\r\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\r\n        amounts[i + 1] = outputAmount\r\n        nextPairs[i] = nextPair\r\n      }\r\n    } else {\r\n      invariant(currencyEquals(amount.token, route.output), 'OUTPUT')\r\n      amounts[amounts.length - 1] = amount\r\n      for (let i = route.path.length - 1; i > 0; i--) {\r\n        const pair = route.pairs[i - 1]\r\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\r\n        amounts[i - 1] = inputAmount\r\n        nextPairs[i - 1] = nextPair\r\n      }\r\n    }\r\n\r\n    this.route = route\r\n    this.tradeType = tradeType\r\n    this.inputAmount = tradeType === TradeType.EXACT_INPUT ? amount : amounts[0]\r\n    this.outputAmount = tradeType === TradeType.EXACT_OUTPUT ? amount : amounts[amounts.length - 1]\r\n    this.executionPrice = new Price(this.inputAmount.token, this.outputAmount.token, this.inputAmount.raw, this.outputAmount.raw)\r\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\r\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\r\n  }\r\n\r\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\r\n  public minimumAmountOut(slippageTolerance: Percent): TokenAmount {\r\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\r\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n      return this.outputAmount\r\n    } else {\r\n      const slippageAdjustedAmountOut = new Fraction(ONE)\r\n        .add(slippageTolerance)\r\n        .invert()\r\n        .multiply(this.outputAmount.raw).quotient\r\n      return new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\r\n  public maximumAmountIn(slippageTolerance: Percent): TokenAmount {\r\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\r\n    if (this.tradeType === TradeType.EXACT_INPUT) {\r\n      return this.inputAmount\r\n    } else {\r\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\r\n      return new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyAmountIn exact amount of input token to spend\r\n   * @param currencyOut the desired token out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\r\n  public static bestTradeExactIn(\r\n    pairs: Pair[],\r\n    currencyAmountIn: TokenAmount,\r\n    currencyOut: Token,\r\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\r\n    // used in recursion.\r\n    currentPairs: Pair[] = [],\r\n    originalAmountIn: TokenAmount = currencyAmountIn,\r\n    bestTrades: Trade[] = []\r\n  ): Trade[] {\r\n    invariant(pairs.length > 0, 'PAIRS')\r\n    invariant(maxHops > 0, 'MAX_HOPS')\r\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\r\n    const chainId: ChainId | undefined =\r\n      currencyAmountIn instanceof TokenAmount ? currencyAmountIn.token.chainId : currencyOut instanceof Token ? currencyOut.chainId : undefined\r\n    invariant(chainId !== undefined, 'CHAIN_ID')\r\n\r\n    const amountIn = currencyAmountIn\r\n    const tokenOut = currencyOut\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const pair = pairs[i]\r\n      // pair irrelevant\r\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\r\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\r\n\r\n      let amountOut: TokenAmount\r\n      try {\r\n        ;[amountOut] = pair.getOutputAmount(amountIn)\r\n      } catch (error) {\r\n        // input too low\r\n        if ((error as any).isInsufficientInputAmountError) {\r\n          continue\r\n        }\r\n        throw error\r\n      }\r\n      // we have arrived at the output token, so this is the final trade of one of the paths\r\n      if (amountOut.token.equals(tokenOut)) {\r\n        sortedInsert(\r\n          bestTrades,\r\n          new Trade(new Route([...currentPairs, pair], originalAmountIn.token, currencyOut), originalAmountIn, TradeType.EXACT_INPUT),\r\n          maxNumResults,\r\n          tradeComparator\r\n        )\r\n      } else if (maxHops > 1 && pairs.length > 1) {\r\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\r\n\r\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n        Trade.bestTradeExactIn(\r\n          pairsExcludingThisPair,\r\n          amountOut,\r\n          currencyOut,\r\n          {\r\n            maxNumResults,\r\n            maxHops: maxHops - 1\r\n          },\r\n          [...currentPairs, pair],\r\n          originalAmountIn,\r\n          bestTrades\r\n        )\r\n      }\r\n    }\r\n\r\n    return bestTrades\r\n  }\r\n\r\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyIn the token to spend\r\n   * @param currencyAmountOut the exact amount of token out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\r\n  public static bestTradeExactOut(\r\n    pairs: Pair[],\r\n    currencyIn: Token,\r\n    currencyAmountOut: TokenAmount,\r\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\r\n    // used in recursion.\r\n    currentPairs: Pair[] = [],\r\n    originalAmountOut: TokenAmount = currencyAmountOut,\r\n    bestTrades: Trade[] = []\r\n  ): Trade[] {\r\n    invariant(pairs.length > 0, 'PAIRS')\r\n    invariant(maxHops > 0, 'MAX_HOPS')\r\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\r\n    const chainId: ChainId | undefined =\r\n      currencyAmountOut instanceof TokenAmount ? currencyAmountOut.token.chainId : currencyIn instanceof Token ? currencyIn.chainId : undefined\r\n    invariant(chainId !== undefined, 'CHAIN_ID')\r\n\r\n    const amountOut = currencyAmountOut\r\n    const tokenIn = currencyIn\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const pair = pairs[i]\r\n      // pair irrelevant\r\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\r\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\r\n\r\n      let amountIn: TokenAmount\r\n      try {\r\n        ;[amountIn] = pair.getInputAmount(amountOut)\r\n      } catch (error) {\r\n        // not enough liquidity in this pair\r\n        if ((error as any).isInsufficientReservesError) {\r\n          continue\r\n        }\r\n        throw error\r\n      }\r\n      // we have arrived at the input token, so this is the first trade of one of the paths\r\n      if (amountIn.token.equals(tokenIn)) {\r\n        sortedInsert(\r\n          bestTrades,\r\n          new Trade(new Route([pair, ...currentPairs], currencyIn, originalAmountOut.token), originalAmountOut, TradeType.EXACT_OUTPUT),\r\n          maxNumResults,\r\n          tradeComparator\r\n        )\r\n      } else if (maxHops > 1 && pairs.length > 1) {\r\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\r\n\r\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n        Trade.bestTradeExactOut(\r\n          pairsExcludingThisPair,\r\n          currencyIn,\r\n          amountIn,\r\n          {\r\n            maxNumResults,\r\n            maxHops: maxHops - 1\r\n          },\r\n          [pair, ...currentPairs],\r\n          originalAmountOut,\r\n          bestTrades\r\n        )\r\n      }\r\n    }\r\n\r\n    return bestTrades\r\n  }\r\n}\r\n","import { TradeType } from './constants'\r\nimport invariant from 'tiny-invariant'\r\nimport { bnToUint256, Uint256 } from 'starknet/dist/utils/uint256'\r\nimport { Percent, Trade } from './entities'\r\n\r\n/**\r\n * Options for producing the arguments to send call to the router.\r\n */\r\nexport interface TradeOptions {\r\n  /**\r\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\r\n   */\r\n  allowedSlippage: Percent\r\n  /**\r\n   * How long the swap is valid until it expires, in seconds.\r\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\r\n   * are generated.\r\n   */\r\n  ttl: number\r\n  /**\r\n   * The account that should receive the output of the swap.\r\n   */\r\n  recipient: string\r\n\r\n  /**\r\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\r\n   */\r\n  feeOnTransfer?: boolean\r\n}\r\n\r\n/**\r\n * The parameters to use in the call to the Uniswap V2 Router to execute a trade.\r\n */\r\nexport interface SwapParameters {\r\n  /**\r\n   * The method to call on the Uniswap V2 Router.\r\n   */\r\n  methodName: string\r\n  /**\r\n   * The arguments to pass to the method, all hex encoded.\r\n   */\r\n  args: string[]\r\n}\r\n\r\n/**\r\n * Represents the Uniswap V2 Router, and has static methods for helping execute trades.\r\n */\r\nexport abstract class Router {\r\n  /**\r\n   * Cannot be constructed.\r\n   */\r\n  private constructor() {}\r\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\r\n  public static swapCallParameters(trade: Trade, options: TradeOptions): SwapParameters {\r\n    invariant(options.ttl > 0, 'TTL')\r\n\r\n    const to: string = options.recipient\r\n    const amountIn: Uint256 = bnToUint256(trade.maximumAmountIn(options.allowedSlippage).raw.toString())\r\n    const amountOut: Uint256 = bnToUint256(trade.minimumAmountOut(options.allowedSlippage).raw.toString())\r\n    const path: string[] = trade.route.path.map(token => token.address)\r\n    const deadline = `${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString()}`\r\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\r\n\r\n    let methodName: string\r\n    let args: string[]\r\n    switch (trade.tradeType) {\r\n      case TradeType.EXACT_INPUT:\r\n        methodName = useFeeOnTransfer ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'\r\n        // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        args = [\r\n          amountIn.low.toString(),\r\n          amountIn.high.toString(),\r\n          amountOut.low.toString(),\r\n          amountOut.high.toString(),\r\n          path.length + '',\r\n          ...path,\r\n          to,\r\n          deadline\r\n        ]\r\n        break\r\n      case TradeType.EXACT_OUTPUT:\r\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\r\n        methodName = 'swapTokensForExactTokens'\r\n        // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        args = [\r\n          amountOut.low.toString(),\r\n          amountOut.high.toString(),\r\n          amountIn.low.toString(),\r\n          amountIn.high.toString(),\r\n          path.length + '',\r\n          ...path,\r\n          to,\r\n          deadline\r\n        ]\r\n        break\r\n    }\r\n    return {\r\n      methodName,\r\n      args\r\n    }\r\n  }\r\n}\r\n","import { Abi, Contract, Provider } from 'starknet'\r\nimport { TokenAmount } from './entities/fractions/tokenAmount'\r\nimport { Pair } from './entities/pair'\r\nimport l0kPairAbi from './abis/l0kPairAbi.json'\r\nimport invariant from 'tiny-invariant'\r\nimport ERC20 from './abis/ERC20.json'\r\nimport { ChainId } from './constants'\r\nimport { Token } from './entities/token'\r\n// import { uint256ToBN } from 'starknet/dist/utils/uint256'\r\n\r\nconst NetworkNames: { [chainId in ChainId]: 'mainnet-alpha' | 'goerli-alpha' } = {\r\n  [ChainId.MAINNET]: 'mainnet-alpha',\r\n  [ChainId.TESTNET]: 'goerli-alpha'\r\n}\r\n\r\nlet TOKEN_DECIMALS_CACHE: { [chainId: string]: { [address: string]: number } } = {\r\n  [ChainId.TESTNET]: {\r\n    '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7': 18 // ETH\r\n  }\r\n}\r\n\r\nasync function getDecimals(chainId: ChainId, address: string, provider: Provider,) {\r\n  if (typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number') {\r\n    return TOKEN_DECIMALS_CACHE[chainId][address]\r\n  }\r\n\r\n  const contract = new Contract(ERC20 as Abi, address, provider)\r\n\r\n  const { decimals } = await contract.call('decimals')\r\n\r\n  TOKEN_DECIMALS_CACHE = {\r\n    ...TOKEN_DECIMALS_CACHE,\r\n    [chainId]: {\r\n      ...TOKEN_DECIMALS_CACHE?.[chainId],\r\n      [address]: decimals.toNumber()\r\n    }\r\n  }\r\n\r\n  return decimals.toNumber()\r\n}\r\n\r\n/**\r\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\r\n */\r\nexport abstract class Fetcher {\r\n  /**\r\n   * Cannot be constructed.\r\n   */\r\n  private constructor() { }\r\n\r\n  /**\r\n   * Fetch information for a given token on the given chain, using the given ethers provider.\r\n   * @param chainId chain of the token\r\n   * @param address address of the token on the chain\r\n   * @param provider provider used to fetch the token\r\n   * @param symbol optional symbol of the token\r\n   * @param name optional name of the token\r\n   */\r\n  public static async fetchTokenData(\r\n    chainId: ChainId,\r\n    address: string,\r\n    provider = new Provider({ network: NetworkNames[chainId] }),\r\n    symbol?: string,\r\n    name?: string\r\n  ): Promise<Token> {\r\n    const parsedDecimals = await getDecimals(chainId, address, provider)\r\n\r\n    return new Token(chainId, address, parsedDecimals, symbol, name)\r\n  }\r\n\r\n  /**\r\n   * Fetches information about a pair and constructs a pair from the given two tokens.\r\n   * @param tokenA first token\r\n   * @param tokenB second token\r\n   * @param provider the provider to use to fetch the data\r\n   */\r\n  public static async fetchPairData(tokenA: Token, tokenB: Token, provider = new Provider({ network: NetworkNames[tokenA.chainId] })): Promise<Pair> {\r\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\r\n    const address = Pair.getAddress(tokenA, tokenB)\r\n    const { reserve0, reserve1 } = await new Contract(l0kPairAbi as Abi, address, provider).call('getReserves', [])\r\n    const balances = tokenA.sortsBefore(tokenB) ? [reserve0, reserve1] : [reserve0, reserve1]\r\n\r\n    return new Pair(new TokenAmount(tokenA, balances[0].toString()), new TokenAmount(tokenB, balances[1].toString()))\r\n  }\r\n}\r\n"],"names":["TradeType","Rounding","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","_this","name","constructor","setPrototypeOf","prototype","_inheritsLoose","Error","InsufficientInputAmountError","_this2","SolidityType","MINIMUM_LIQUIDITY","JSBI","BigInt","ZERO","ONE","TWO","THREE","FIVE","TEN","_100","FEES_NUMERATOR","FEES_DENOMINATOR","SOLIDITY_TYPE_MAXIMA","uint8","uint256","FACTORY_ADDRESSES","StarknetChainId","MAINNET","TESTNET","CONTRACT_ADDRESS_PREFIX","encodeShortString","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","invariant","lessThanOrEqual","validateAndParseAddress","address","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","getPairAddress","tokenA","tokenB","tokens","sortsBefore","salt","pedersen","constructorCalldataHash","computeHashOnElements","chainId","isEqualAddress","addressA","addressB","toBN","eq","lt","Token","decimals","symbol","this","_proto","equals","other","currencyEquals","currencyA","currencyB","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","equal","multiply","subtract","equalTo","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","set","precision","quotient","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","_createClass","key","get","remainder","TokenAmount","token","amount","parsedAmount","exponentiate","raw","toExact","Price","baseCurrency","quoteCurrency","scalar","fromRoute","route","prices","pairs","entries","pair","path","token0","reserve0","reserve1","slice","reduce","accumulator","currentValue","fraction","quote","currencyAmount","_Fraction","adjusted","PAIR_ADDRESS_CACHE","Pair","tokenAmountA","tokenAmountB","tokenAmounts","liquidityToken","undefined","_PAIR_ADDRESS_CACHE2","involvesToken","token1","priceOf","token0Price","token1Price","reserveOf","getOutputAmount","inputAmount","inputReserve","outputReserve","inputAmountWithFee","outputAmount","getInputAmount","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","Route","input","output","every","currentInput","midPrice","_100_PERCENT","Percent","inputOutputComparator","a","b","tradeComparator","ioComp","priceImpact","Trade","tradeType","exactQuote","slippage","amounts","Array","nextPairs","EXACT_INPUT","i","nextPair","EXACT_OUTPUT","executionPrice","nextMidPrice","exactIn","amountIn","exactOut","amountOut","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","currentPairs","originalAmountIn","bestTrades","maxNumResults","maxHops","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn","isInsufficientReservesError","Router","swapCallParameters","trade","options","ttl","methodName","args","to","recipient","bnToUint256","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","low","high","NetworkNames","ChainId","TOKEN_DECIMALS_CACHE","0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7","Fetcher","fetchTokenData","provider","Provider","network","_TOKEN_DECIMALS_CACHE2","_TOKEN_DECIMALS_CACHE3","contract","Contract","ERC20","call","_TOKEN_DECIMALS_CACHE4","toNumber","getDecimals","parsedDecimals","fetchPairData","l0kPairAbi","balances"],"mappings":"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"}